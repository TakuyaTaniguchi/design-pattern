# Proxyパターン

Proxyパターンは、別のオブジェクトへのアクセスを制御するためのインターフェースを提供するデザインパターンです。

## 基本概念

Proxyパターンは、あるオブジェクトの代わりに別のオブジェクト（プロキシ）を使用して、元のオブジェクトへのアクセスを制御します。プロキシは実際のオブジェクトと同じインターフェースを実装し、クライアントはプロキシと実際のオブジェクトの区別がつきません。

## 実装パターン

1. **仮想プロキシ（Virtual Proxy）**
    - 重いリソースの遅延読み込み（LazyImage例）
    - 必要になるまでリソースの初期化を遅らせる

2. **キャッシュプロキシ（Cache Proxy）**
    - 結果をキャッシュして再利用（ApiServiceProxy例）
    - 重い操作の繰り返し実行を回避

3. **保護プロキシ（Protection Proxy）**
    - アクセス制御を提供
    - 権限に基づいてリソースへのアクセスを制限

4. **リモートプロキシ（Remote Proxy）**
    - リモートリソースへのアクセスをローカルに表現
    - ネットワーク通信の詳細を隠蔽

## メリット

1. **分離と制御**: リソースへのアクセスを制御できる
2. **最適化**: キャッシュや遅延読み込みにより効率化
3. **セキュリティ**: アクセス制御やバリデーションの追加
4. **透過性**: クライアントコードを変更せずに機能拡張

## ユースケース

1. **APIクライアント**
    - API呼び出しのキャッシュ
    - エラーハンドリングと再試行ロジック
    - リクエスト/レスポンスの前処理・後処理

2. **リソースの遅延読み込み**
    - 画像やビデオなどの重いコンテンツ
    - データベース接続
    - 設定ファイルの読み込み

3. **アクセス制御**
    - 認証・認可
    - レート制限
    - 監査ログ

## サンプル実装

このリポジトリには以下のサンプルが含まれています：

1. `ApiService.ts` - APIリクエストのプロキシ（キャッシング、ロギング、エラーハンドリング）
2. `LazyImage.tsx` - 画像の遅延読み込みとキャッシュ

## TypeScriptでの実装のポイント

- インターフェースを使用して実際のオブジェクトとプロキシの契約を定義
- プロキシと実際のオブジェクトが同じインターフェースを実装
- 実際のオブジェクトへの参照をプロキシ内に持つ
- 必要に応じて追加機能（キャッシュ、ログなど）を実装

## 関連パターン

- **Decoratorパターン**: 機能の追加方法が異なる（プロキシはアクセス制御、デコレータは機能拡張）
- **Adapterパターン**: インターフェースの変換が目的（プロキシはインターフェースを変えない）
- **Facadeパターン**: 複雑なサブシステムの簡略化が目的